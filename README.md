![image](https://github.com/user-attachments/assets/3a7c7823-f77d-47a7-ae5f-d9877efe93a8)![image](https://github.com/user-attachments/assets/ce3721c6-5eef-4b20-ac4f-e90d56e8b9d0)# Exp4
Profiling and BDD implementation in Java

## پرسش ها

۲- در انتهای مستند هنگام اجرای Scenario Outline برخی تست‌ها به مشکل undefined برمی‌خورند.

+این موارد تست کدامند؟

ردیف دوم example یعنی ورودی -۱ و ۶

علیت بروز مشکل چیست؟+

در قسمت given یعنی تابع twoInputValuesAnd؟، رجکس تعریف شده برای گرفتن دو عدد فیرمنقی تعریف شده است و در تست به مشکل خورده، ورودی -۱ داده شده که منفی است.

مشکل را با تغییر کد رفع کتید.+

با اضافه کردن -؟ به رجکس گرفتن عددها، دیگر از اعداد منفی هم پشتیبانی می‌شود و قابل قبول هستند. (؟ در رحکس به معنای ۰ یا یک می‌باشد.)
## تمرین های بخش profiling:
## عملیات profiling  بر روی JavaCup:
ابتدا با انجام تست profiling میبینیم که منابع به چه شکلی تخصیص داده می شوند.
در اینجا رشد cpu time را با دادن هر ورودی به آن مشاهده میکنیم و میبینیم که رشد صعودی ای دارد
![image](https://github.com/user-attachments/assets/05737529-53da-4a52-8d75-956bbd8d8a65).
همچنین خلاصه ای از بخش ران تایم در بخش summary مشاهده میکنیم.
![image](https://github.com/user-attachments/assets/4058a3dc-3f0b-4a5f-8624-da24fcb67d13)

خلاصه ای از بخش های تخصیص حافظه:

![image](https://github.com/user-attachments/assets/0e0cc48b-2741-4b8e-a5c9-672ed07e627f)
همانطور که میبینید تابع temp تابعیست که بیشترین منبع را برای ما اشفال میکند و بعنوان hotspot method  نمایش داده شده است پس باید این تابع را بهینه کنیم:
![image](https://github.com/user-attachments/assets/7f27b2c8-bfb4-4b61-bfdb-6c8ab60cf1bd)

در اینجا تغییر ایجاد شده در تابع temp برای بهینه سازی مشاهده میکنیم
![image](https://github.com/user-attachments/assets/4587fced-7bf4-4f3a-a5e4-6e1fbe4f25bf)
مشکل کد قبلی در متد temp این بود که از دو حلقه تو در تو برای اضافه کردن مقادیر به یک ArrayList استفاده می‌کرد. این باعث می‌شد که تعداد زیادی عنصر به لیست اضافه شود که به شدت حافظه را اشغال کرده و عملکرد برنامه را کاهش می‌داد که در آن، دو حلقه تو در تو داریم که برای هر ترکیب از i و j یک مقدار به لیست اضافه می‌کنند. این کار باعث می‌شود لیست خیلی بزرگ شود و زمان زیادی صرف اضافه کردن عناصر به آن شود.

روش بهبود کدی که استفاده کردیم:
برای بهبود این کد، تغییراتی ایجاد شد تا استفاده از منابع بهینه‌تر شود. حالا لیست را یکبار ایجاد می‌کنیم و مقادیر را به آن اضافه می‌کنیم، سپس در حلقه‌های تو در تو به جای اضافه کردن مقادیر جدید به لیست، روی مقادیر موجود عملیات انجام می‌دهیم.
با اعمال ایجاد یکباره ی  لیست(به جای اضافه کردن مقادیر به لیست در هر تکرار حلقه تو در تو، یکبار لیست را با اندازه ثابت ایجاد می‌کنیم و مقادیر را به آن اضافه می‌کنیم) و پردازش اعضای لیست× در حلقه‌های تو در تو به جای اضافه کردن مقادیر جدید به لیست، مقادیر موجود را پردازش می‌کنیم. این باعث کاهش مصرف حافظه و بهبود عملکرد می‌شود.
## ایجاد قطعه کد جدید و بهبود آن.
ما در اینجا یک پروژه ی نقشه ی مترو را پیاده سازی کرده ایم.درآن نخست ایستگاه های مختلف و خط های موجود در هر مترو و اتصال آنها را ایجاد میکنیم.سپس با گرفتن تو ایستگاه بعنوان ورودی مصیر بین هر یک،توسط برنامه به ما نمایش داده می شود.ابتدا آن را با DFS حل میکنیم.طی روند پروژه به نامناسب بودن این الگوریتم به مشاهده ی روند اختصاص منابع پی میبریم.سپس آن را با بهینه میکنیم و از الگوریتم bfs استفاده مینماییم.هر بخش پروژه وقتی مصیر بین دو ایستگاه طی می شود آن را درخروجی نمایش داده و همچنین مدت انجام آن ۱ ثانیه طول میکشد.

## انجام تست پروفایلینگ در الگوریتم DFS:
![image](https://github.com/user-attachments/assets/132f3b4c-064c-4154-a2df-a09119d6937d)
همانطور که میبینید بخش عظیمی درگیر ران کردن بخش مربوط به dfs کد بوده است
![image](https://github.com/user-attachments/assets/16ddd742-8d90-4c1d-8341-f71db517f364)

بخش مموری را مشاهده میکنیم:
![image](https://github.com/user-attachments/assets/b60293ae-f02c-43a3-8cc3-83889ea001df)
خلاصه ی ران تایم را مشاهده میکنیم:
![image](https://github.com/user-attachments/assets/cb4c7680-6f62-4b4d-9f86-1acf8529f0bc)
همانطور که در بخش Hotspots میبینیم به این موضوع اشاره شده که متود findPathNaive دارد بخش زیادی از زمان را به خود اختصاص میدهد پس باید آن را بهینه کنیم
![image](https://github.com/user-attachments/assets/794fa14f-a582-41f6-b8d9-1602e88a4732)

## انجام تست پروفایلینگ در الگوریتم BFS:
زمان بندی CPU با الگوریتم BFS:
![image](https://github.com/user-attachments/assets/792478a2-11c8-4071-89ad-cfd59e7aef82)
![image](https://github.com/user-attachments/assets/b789ebb9-1333-4ed9-af90-5db4eac4b9c0)
![image](https://github.com/user-attachments/assets/493bf9f2-97e8-4d83-b4e0-976402e63d72)
خلاصه ای از ران تایم:
![image](https://github.com/user-attachments/assets/ffe491b0-58de-4200-b37f-ca61ff992b79)
و همیچنین وضعیت حافظه را مشاهده میکنم:
![image](https://github.com/user-attachments/assets/2f9d60a4-e51d-4bfd-b775-20849d4940fa)
همانطور که دیدیم کل روند اختصاص منابع (چه حافطه و چه CPU بهبود یافت)














